/**
 * Reorder Utils
 * Utilities for sorting and organizing place results based on AI output
 */

/**
 * Sorts a list of places based on their order of appearance in the AI's textual answer.
 * Uses a fuzzy matching strategy to handle variations in naming (e.g. "Name" vs "Name - Slogan").
 * 
 * @param {Array} places - Array of Place documents from MongoDB
 * @param {String} answer - The text answer generated by the AI
 * @returns {Array} - Sorted array of places
 */
const escapeRegExp = (string) => {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
};

const findSafeMatchIndex = (text, search) => {
    if (!search || !text) return -1;
    try {
        const escaped = escapeRegExp(search);
        // Look for the search term NOT followed by a letter (Unicode property escape for international letters)
        // This prevents "QuÃ¡n chÃ¨ An" matching "QuÃ¡n chÃ¨ Anh..."
        const regex = new RegExp(`${escaped}(?![\\p{L}])`, 'iu');
        const match = text.match(regex);
        return match ? match.index : -1;
    } catch (e) {
        // Fallback or old browsers without unicode properties
        return text.toLowerCase().indexOf(search.toLowerCase());
    }
};

export const sortPlacesByAnswerOrder = (places, answer) => {
    if (!answer || !places || places.length === 0) {
        return places;
    }

    const answerLower = answer.toLowerCase();

    const scoredPlaces = places.map(p => {
        const nameLower = p.name.toLowerCase();
        let index = -1;

        // Strategy 1: Find full name
        index = findSafeMatchIndex(answerLower, nameLower);

        // Strategy 2: Find short name (before hyphen) if full name not found
        // Usage: Matches "Freetalk Cafe" from "Freetalk Cafe - KhÃ´ng gian..."
        if (index === -1) {
            const shortName = nameLower.split(' - ')[0].trim();
            // Avoid matching extremely short symbols/words like "The" if that was a name
            if (shortName.length > 2) {
                index = findSafeMatchIndex(answerLower, shortName);
            }
        }

        // Strategy 3: Find just the first 3 words (for long names without hyphens)
        if (index === -1) {
            const words = nameLower.split(' ');
            if (words.length >= 3) {
                const firstThree = words.slice(0, 3).join(' ');
                index = findSafeMatchIndex(answerLower, firstThree);
            }
        }

        return {
            place: p,
            // If found, use index. If not found, use Infinity to put at end.
            index: index !== -1 ? index : Infinity,
            // Secondary sort: if not in answer, keep original rank (from retrieval)
            originalIndex: places.indexOf(p)
        };
    });

    // Sort: 
    // 1. Found items first (lower index)
    // 2. If both not found, maintain original retrieval order
    scoredPlaces.sort((a, b) => {
        if (a.index !== b.index) {
            return a.index - b.index;
        }
        return a.originalIndex - b.originalIndex;
    });

    return scoredPlaces.map(item => item.place);
};

/**
 * Helper: Normalize string for flexible matching
 * - Lowercase
 * - Remove Vietnamese accents (optional, but good for robust search)
 * - Normalize punctuation (â€“ to -)
 */
const normalizeForMatch = (str) => {
    return str.toLowerCase()
        .replace(/Ã |Ã¡|áº¡|áº£|Ã£|Ã¢|áº§|áº¥|áº­|áº©|áº«|Äƒ|áº±|áº¯|áº·|áº³|áºµ/g, "a")
        .replace(/Ã¨|Ã©|áº¹|áº»|áº½|Ãª|á»|áº¿|á»‡|á»ƒ|á»…/g, "e")
        .replace(/Ã¬|Ã­|á»‹|á»‰|Ä©/g, "i")
        .replace(/Ã²|Ã³|á»|á»|Ãµ|Ã´|á»“|á»‘|á»™|á»•|á»—|Æ¡|á»|á»›|á»£|á»Ÿ|á»¡/g, "o")
        .replace(/Ã¹|Ãº|á»¥|á»§|Å©|Æ°|á»«|á»©|á»±|á»­|á»¯/g, "u")
        .replace(/á»³|Ã½|á»µ|á»·|á»¹/g, "y")
        .replace(/Ä‘/g, "d")
        .replace(/â€“|â€”/g, "-") // Normalize dashes
        .replace(/\s+/g, " ") // Collapse spaces
        .trim();
};

/**
 * Sorts and FILTERS places. Only returns places actually mentioned in the answer.
 * @param {Array} places 
 * @param {String} answer 
 */
export const filterAndSortPlaces = (places, answer) => {
    if (!answer || !places || places.length === 0) {
        return [];
    }

    let searchScope = answer;
    let offset = 0;

    // ðŸ§  SMART SORTING: Ignore "Intro" text for Itineraries
    // Why? If Intro says "Visit Ho Guom and Lang Bac", but Step 1 is "Lang Bac",
    // simple matching would put "Ho Guom" first (wrong order).
    // Solution: Only start searching from "**1." (the first step).
    const startMarker = '**1.';
    const startIndex = answer.indexOf(startMarker);
    if (startIndex !== -1) {
        searchScope = answer.substring(startIndex);
        offset = startIndex; // Keep offset to calculate real absolute index if needed
    }

    const answerLower = searchScope.toLowerCase();
    const answerNormalized = normalizeForMatch(searchScope);

    const matchedPlaces = places.map(p => {
        const nameOriginal = p.name;
        const nameLower = nameOriginal.toLowerCase();
        const nameNormalized = normalizeForMatch(nameOriginal);

        // --- MATCHING STRATEGIES ---
        let index = -1;

        // 1. Exact Match (Case-insensitive)
        index = findSafeMatchIndex(answerLower, nameLower);

        // 2. Normalized Match (Ignore accents/dashes)
        if (index === -1) {
            const normIndex = answerNormalized.indexOf(nameNormalized);
            if (normIndex !== -1) {
                index = normIndex;
            }
        }

        // 3. Short Name (Before " - ")
        if (index === -1 && nameLower.includes(' - ')) {
            const shortName = nameLower.split(' - ')[0].trim();
            if (shortName.length > 2) {
                index = findSafeMatchIndex(answerLower, shortName);
            }
        }

        // 4. Token Intersection
        if (index === -1) {
            const words = nameNormalized.split(' ').filter(w => w.length > 2);
            if (words.length >= 3) {
                const lastTwo = words.slice(-2).join(' ');
                // ðŸ›¡ï¸ SAFETY: Avoid matching common location suffixes
                const BLACKLIST_PHRASES = [
                    'ha noi', 'viet nam', 'mien bac',
                    'hoan kiem', 'ba dinh', 'tay ho', 'dong da', 'cau giay',
                    'hai ba trung', 'thanh xuan', 'hoang mai', 'long bien',
                    'pho co', 'ha dong'
                ];
                if (!BLACKLIST_PHRASES.includes(lastTwo)) {
                    const lastTwoIndex = answerNormalized.indexOf(lastTwo);
                    if (lastTwoIndex !== -1) {
                        index = lastTwoIndex;
                    }
                }
            }
        }

        // 5. "QuÃ¡n" Prefix handling
        if (index === -1) {
            const prefixes = ['quÃ¡n', 'nhÃ  hÃ ng', 'tiá»‡m'];
            for (const prefix of prefixes) {
                if (nameLower.startsWith(prefix + ' ')) {
                    const nameWithoutPrefix = nameLower.substring(prefix.length + 1);
                    index = findSafeMatchIndex(answerLower, nameWithoutPrefix);
                    if (index !== -1) break;
                }
            }
        }

        return {
            place: p,
            index: index
        };
    }).filter(item => item.index !== -1);

    // ðŸ” DEBUG: Log matching status
    console.log(`\nðŸ” MATCHING STRATEGY DEBUG: Found ${matchedPlaces.length}/${places.length} places mentioned in text.`);

    // Sort by appearance order
    matchedPlaces.sort((a, b) => a.index - b.index);

    return matchedPlaces.map(item => item.place);
};
