/**
 * Reorder Utils
 * Utilities for sorting and organizing place results based on AI output
 */

/**
 * Sorts a list of places based on their order of appearance in the AI's textual answer.
 * Uses a fuzzy matching strategy to handle variations in naming (e.g. "Name" vs "Name - Slogan").
 * 
 * @param {Array} places - Array of Place documents from MongoDB
 * @param {String} answer - The text answer generated by the AI
 * @returns {Array} - Sorted array of places
 */
const escapeRegExp = (string) => {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
};

const findSafeMatchIndex = (text, search) => {
    if (!search || !text) return -1;
    try {
        const escaped = escapeRegExp(search);
        // Look for the search term NOT followed by a letter (Unicode property escape for international letters)
        // This prevents "Quán chè An" matching "Quán chè Anh..."
        const regex = new RegExp(`${escaped}(?![\\p{L}])`, 'iu');
        const match = text.match(regex);
        return match ? match.index : -1;
    } catch (e) {
        // Fallback or old browsers without unicode properties
        return text.toLowerCase().indexOf(search.toLowerCase());
    }
};

export const sortPlacesByAnswerOrder = (places, answer) => {
    if (!answer || !places || places.length === 0) {
        return places;
    }

    const answerLower = answer.toLowerCase();

    const scoredPlaces = places.map(p => {
        const nameLower = p.name.toLowerCase();
        let index = -1;

        // Strategy 1: Find full name
        index = findSafeMatchIndex(answerLower, nameLower);

        // Strategy 2: Find short name (before hyphen) if full name not found
        // Usage: Matches "Freetalk Cafe" from "Freetalk Cafe - Không gian..."
        if (index === -1) {
            const shortName = nameLower.split(' - ')[0].trim();
            // Avoid matching extremely short symbols/words like "The" if that was a name
            if (shortName.length > 2) {
                index = findSafeMatchIndex(answerLower, shortName);
            }
        }

        // Strategy 3: Find just the first 3 words (for long names without hyphens)
        if (index === -1) {
            const words = nameLower.split(' ');
            if (words.length >= 3) {
                const firstThree = words.slice(0, 3).join(' ');
                index = findSafeMatchIndex(answerLower, firstThree);
            }
        }

        return {
            place: p,
            // If found, use index. If not found, use Infinity to put at end.
            index: index !== -1 ? index : Infinity,
            // Secondary sort: if not in answer, keep original rank (from retrieval)
            originalIndex: places.indexOf(p)
        };
    });

    // Sort: 
    // 1. Found items first (lower index)
    // 2. If both not found, maintain original retrieval order
    scoredPlaces.sort((a, b) => {
        if (a.index !== b.index) {
            return a.index - b.index;
        }
        return a.originalIndex - b.originalIndex;
    });

    return scoredPlaces.map(item => item.place);
};
